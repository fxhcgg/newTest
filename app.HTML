<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>手动起点终点 · 极简稳版</title>
<style>
  html,body{margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  #cam{position:fixed;inset:0;object-fit:cover;background:#000;z-index:0;}
  #gl{position:fixed;inset:0;z-index:1;pointer-events:none;} /* 画布完全不抢事件 */
  .panel{position:fixed;left:12px;right:12px;bottom:12px;z-index:3;background:rgba(0,0,0,.55);color:#fff;border-radius:12px;padding:12px;backdrop-filter:blur(6px);}
  .panel *{pointer-events:auto;touch-action:auto}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:8px}
  select,button{font-size:14px;background:#111;color:#fff;border:1px solid #333;border-radius:10px;padding:8px 10px}
  .bigbtn{font-size:16px;padding:10px 12px}
  .hud{position:fixed;left:12px;top:12px;z-index:3;background:rgba(0,0,0,.35);color:#fff;padding:8px 10px;border-radius:10px;font-size:13px;line-height:1.4}
  .diag{position:fixed;right:12px;top:12px;z-index:3;background:rgba(0,0,0,.5);color:#fff;padding:8px 10px;border-radius:10px;font-size:12px;line-height:1.5;max-width:46vw;}
  .ok{color:#7CFC00} .warn{color:#FFD700} .err{color:#FF6B6B}
</style>
</head>
<body>
<video id="cam" autoplay playsinline muted></video>
<canvas id="gl"></canvas>

<div class="hud" id="hud">起点: N/A → 终点: N/A<br>距离: — m</div>
<div class="diag" id="diag">加载中…</div>

<div class="panel">
  <div class="row" id="quick" style="display:none"></div>
  <div class="row">
    <label>起点</label>
    <select id="start"><option value="">未选择</option></select>
    <label>终点</label>
    <select id="end"><option value="">未选择</option></select>
    <button id="swap">交换</button>
  </div>
</div>

<!-- 内联兜底（如果同目录 rooms_world.geojson 读不到就用这份；你也可以把内容替换成自己的） -->
<script id="rooms_inline" type="application/json">
{
  "type":"FeatureCollection",
  "features":[
    { "type":"Feature",
      "properties":{"room_id":1,"name":"RoomA"},
      "geometry":{"type":"Polygon","coordinates":[[[0,0],[4,0],[4,3],[0,3],[0,0]]] }
    },
    { "type":"Feature",
      "properties":{"room_id":2,"name":"RoomB"},
      "geometry":{"type":"Polygon","coordinates":[[[6,0],[10,0],[10,3],[6,3],[6,0]]] }
    }
  ]
}
</script>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(async function(){
  const FILES = { rooms:'rooms_world.geojson', plyPrimary:'oriented.ply', plyFallback:'sparse.ply' };
  const diag = document.getElementById('diag'); const log=(h,c='')=>diag.innerHTML += '<br>'+(c?`<span class="${c}">`:'')+h+(c?'</span>':'');
  // 摄像头（失败不阻塞）
  try{ const t=performance.now(); const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}},audio:false}); document.getElementById('cam').srcObject=s; log(`Camera OK (${(performance.now()-t|0)}ms)`,'ok'); }catch(e){ log('Camera FAILED（继续）','warn'); }

  // Three 基础
  const cnv = document.getElementById('gl');
  const renderer = new THREE.WebGLRenderer({canvas:cnv, antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio||1);
  renderer.setSize(window.innerWidth, window.innerHeight, false);
  const scene = new THREE.Scene(); scene.background=null;
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 5000);
  scene.add(new THREE.AmbientLight(0xffffff,1.0));
  const world = new THREE.Group(); scene.add(world);
  const roomsGroup = new THREE.Group(); world.add(roomsGroup);
  const pathLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineDashedMaterial({color:0xffffff, dashSize:0.3, gapSize:0.15})); pathLine.computeLineDistances(); world.add(pathLine);

  // 状态
  let rooms=[]; let startPos=null, endPos=null; let pcObj=null;

  // 读取 rooms：优先同目录 fetch，失败用内联兜底
  async function loadRooms(){
    try{
      const r=await fetch(FILES.rooms, {cache:'no-store'});
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }catch(e){
      const txt=document.getElementById('rooms_inline')?.textContent;
      if(!txt) throw e;
      log('rooms_world.geojson 使用内联兜底','warn');
      return JSON.parse(txt);
    }
  }

  try{
    const gj = await loadRooms();
    if(!gj||!Array.isArray(gj.features)) throw new Error('GeoJSON 无 features');
    rooms = gj.features.map((f,i)=>{
      const prop=f.properties||{};
      const poly=(f.geometry&&f.geometry.type==='Polygon')? f.geometry.coordinates[0]:[];
      return { id: prop.room_id ?? (i+1), name: prop.name ?? '', poly, centroid: centroid(poly) };
    });
    drawRooms(rooms);
    populateSelectors(rooms);
    if (rooms.length>=1){ setStartByRoom(rooms[0].id); }
    if (rooms.length>=2){ setEndByRoom(rooms[1].id); }
    fitViewToRooms(rooms);
    updatePathAndHUD();
    log(`rooms OK (count=${rooms.length})`,'ok');
  }catch(e){ log(`rooms FAILED: ${e.message||e}`,'err'); return; }

  // 点云（可选）
  try{
    let r=await fetch(FILES.plyPrimary,{cache:'no-store'}); if(!r.ok) r=await fetch(FILES.plyFallback,{cache:'no-store'});
    if(r.ok){ const buf=await r.arrayBuffer(); const pts=parsePLY(buf); if(pts.length){ addPointCloud(pts); log(`PLY OK (points=${pts.length})`,'ok'); } else { log('PLY EMPTY','warn'); } }
  }catch(e){ log(`PLY FAILED: ${e.message||e}`,'warn'); }

  // DOM refs
  const selS=document.getElementById('start'); const selE=document.getElementById('end'); const quick=document.getElementById('quick'); const hud=document.getElementById('hud');

  // 下拉变化
  selS.addEventListener('change', ()=>{ const id=selS.value; if(id) setStartByRoom(id); });
  selE.addEventListener('change', ()=>{ const id=selE.value; if(id) setEndByRoom(id); });
  document.getElementById('swap').addEventListener('click', ()=>{
    const tmp=selS.value; selS.value=selE.value; selE.value=tmp;
    if(selS.value) setStartByRoom(selS.value); else startPos=null;
    if(selE.value) setEndByRoom(selE.value); else endPos=null;
  });

  // —— 纯按钮逻辑（保证“能点”）——
  function populateSelectors(rs){
    // 填下拉
    rs.forEach(r=>{
      const o1=document.createElement('option'); o1.value=String(r.id); o1.textContent=`${r.name||r.id}`; selS.appendChild(o1);
      const o2=o1.cloneNode(true); selE.appendChild(o2);
    });
    // 两房间 → 快捷按钮
    if (rs.length>=1){
      quick.style.display='';
      quick.innerHTML = ''; // 清空
      rs.forEach(r=>{
        const bs=document.createElement('button'); bs.className='bigbtn'; bs.textContent=`设起点：${r.name||r.id}`;
        bs.addEventListener('click', ()=>{ setStartByRoom(r.id); selS.value=String(r.id); });
        const be=document.createElement('button'); be.className='bigbtn'; be.textContent=`设终点：${r.name||r.id}`;
        be.addEventListener('click', ()=>{ setEndByRoom(r.id); selE.value=String(r.id); });
        quick.appendChild(bs); quick.appendChild(be);
      });
    }
  }

  function setStartByRoom(roomId){
    const r=rooms.find(x=>String(x.id)===String(roomId)); if(!r) return;
    startPos = new THREE.Vector3(r.centroid[0],0,r.centroid[1]);
    updatePathAndHUD();
  }
  function setEndByRoom(roomId){
    const r=rooms.find(x=>String(x.id)===String(roomId)); if(!r) return;
    endPos = new THREE.Vector3(r.centroid[0],0,r.centroid[1]);
    updatePathAndHUD();
  }

  // 画房间 & 路径
  function drawRooms(rs){
    roomsGroup.clear();
    const lineMat=new THREE.LineBasicMaterial({color:0x00A2FF});
    const fillMat=new THREE.MeshBasicMaterial({color:0x0066ff, transparent:true, opacity:.12, depthWrite:false});
    rs.forEach(r=>{
      const up=0.02;
      const shape=new THREE.Shape(); r.poly.forEach(([x,y],k)=> k?shape.lineTo(x,y):shape.moveTo(x,y)); shape.autoClose=true;
      const pts3=r.poly.map(([x,y])=> new THREE.Vector3(x,up,y));
      const geoLine=new THREE.BufferGeometry().setFromPoints(pts3.concat([pts3[0]]));
      roomsGroup.add(new THREE.Line(geoLine,lineMat));
      const geo=new THREE.ShapeGeometry(shape);
      const mesh=new THREE.Mesh(geo,fillMat); mesh.rotation.x=-Math.PI/2; mesh.position.y=up;
      roomsGroup.add(mesh);
    });
  }

  function updatePathAndHUD(){
    const geo=new THREE.BufferGeometry();
    const pts=[];
    if(startPos) pts.push(new THREE.Vector3(startPos.x,0.05,startPos.z));
    if(endPos)   pts.push(new THREE.Vector3(endPos.x,0.05,endPos.z));
    geo.setFromPoints(pts);
    pathLine.geometry.dispose(); pathLine.geometry=geo; pathLine.computeLineDistances();
    let dist='—'; if(startPos&&endPos) dist=startPos.clone().setY(0).distanceTo(endPos.clone().setY(0)).toFixed(2);
    hud.innerHTML=`起点: ${startPos?`${startPos.x.toFixed(2)},${startPos.z.toFixed(2)}`:'N/A'} → 终点: ${endPos?`${endPos.x.toFixed(2)},${endPos.z.toFixed(2)}`:'N/A'}<br>距离: ${dist} m`;
  }

  // 视角
  function fitViewToRooms(rs){
    let minX= Infinity, maxX=-Infinity, minZ= Infinity, maxZ=-Infinity;
    rs.forEach(r=> r.poly.forEach(([x,z])=>{ if(x<minX)minX=x; if(x>maxX)maxX=x; if(z<minZ)minZ=z; if(z>maxZ)maxZ=z; }));
    const cx=(minX+maxX)/2, cz=(minZ+maxZ)/2, span=Math.max(1, maxX-minX, maxZ-minZ);
    camera.position.set(cx, span*0.8, cz+span*1.6);
    camera.lookAt(cx,0,cz);
  }

  // 点云（可选）
  function addPointCloud(points){
    if(pcObj){ world.remove(pcObj); pcObj.geometry.dispose(); }
    const arr=new Float32Array(points.length*3);
    for(let i=0;i<points.length;i++){ arr[i*3]=points[i][0]; arr[i*3+1]=points[i][1]; arr[i*3+2]=points[i][2]; }
    const g=new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(arr,3));
    const m=new THREE.PointsMaterial({color:0x00ff00, size:0.03, sizeAttenuation:true});
    pcObj=new THREE.Points(g,m); world.add(pcObj);
  }
  function parsePLY(buffer){
    const bytes=new Uint8Array(buffer); let hEnd=-1, header="";
    for(let i=0;i<bytes.length&&i<1e6;i++){ header+=String.fromCharCode(bytes[i]); if(header.includes("end_header\n")){ hEnd=i+1; break; } }
    if(hEnd<0) return [];
    const lines=header.split(/\r?\n/); let n=0,isBin=false,little=true; const props=[];
    for(const Lraw of lines){ const L=Lraw.trim().toLowerCase();
      if(L.startsWith("format binary_little_endian")){ isBin=true; little=true; }
      if(L.startsWith("format ascii")) isBin=false;
      if(L.startsWith("element vertex")) n=parseInt(L.split(/\s+/)[2],10);
      if(L.startsWith("property")){ const p=L.split(/\s+/); if(p.length>=3) props.push({type:p[1],name:p[2]}); }
    }
    if(!n) return [];
    const pts=new Array(n);
    if(!isBin){
      const tail=new TextDecoder().decode(bytes.slice(hEnd)); const rows=tail.split(/\r?\n/); let k=0;
      for(const r of rows){ const s=r.trim(); if(!s) continue; const t=s.split(/\s+/); if(t.length>=3){ pts[k++]=[+t[0],+t[1],+t[2]]; if(k>=n) break; } }
      return pts.slice(0,n);
    } else {
      const view=new DataView(buffer,hEnd); let off=0;
      function read(type,off){ switch(type){
        case'float':case'float32':return[view.getFloat32(off,little),4];
        case'double':return[view.getFloat64(off,little),8];
        case'uchar':case'uint8':return[view.getUint8(off),1];
        case'char':case'int8':return[view.getInt8(off),1];
        case'ushort':case'uint16':return[view.getUint16(off,little),2];
        case'short':case'int16':return[view.getInt16(off,little),2];
        case'uint':case'uint32':return[view.getUint32(off,little),4];
        case'int':case'int32':return[view.getInt32(off,little),4];
        default:return[0,0];}}
      for(let i=0;i<n;i++){
        let x=0,y=0,z=0;
        for(const p of props){ const [v,step]=read(p.type,off); off+=step; if(p.name==='x')x=v; else if(p.name==='y')y=v; else if(p.name==='z')z=v; }
        pts[i]=[x,y,z];
      }
      return pts;
    }
  }

  // 渲染循环（只渲染，不接事件）
  function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); }
  animate();

  // 自适应
  window.addEventListener('resize', ()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight, false);
  });

  function centroid(poly){
    if(!poly||poly.length<3) return [0,0];
    let x=0,y=0,a=0;
    for(let i=0;i<poly.length;i++){ const [x0,y0]=poly[i], [x1,y1]=poly[(i+1)%poly.length]; const c=x0*y1-x1*y0; a+=c; x+=(x0+x1)*c; y+=(y0+y1)*c; }
    if (Math.abs(a)<1e-9){ let sx=0,sy=0; for(const p of poly){ sx+=p[0]; sy+=p[1]; } return [sx/poly.length, sy/poly.length]; }
    a*=0.5; x/=(6*a); y/=(6*a); return [x,y];
  }
})();
</script>
</body>
</html>
