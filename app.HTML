<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>两房间手动导航（带自检）</title>
<style>
  html,body{margin:0;background:#000;overflow:hidden;touch-action:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  #cam{position:fixed;left:0;top:0;width:100vw;height:100vh;object-fit:cover;background:#000;z-index:0;}
  #gl{position:fixed;left:0;top:0;width:100vw;height:100vh;z-index:1;pointer-events:none;}
  .panel{position:fixed;left:12px;right:12px;bottom:12px;z-index:3;background:rgba(0,0,0,.45);color:#fff;border-radius:12px;padding:10px 12px;backdrop-filter:blur(6px);}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:6px}
  select,button{font-size:12px;background:#111;color:#fff;border:1px solid #333;border-radius:8px;padding:6px 8px}
  .hud{position:fixed;left:12px;top:12px;z-index:3;background:rgba(0,0,0,.35);color:#fff;padding:8px 10px;border-radius:10px;font-size:12px;line-height:1.4}
  .diag{position:fixed;right:12px;top:12px;z-index:3;background:rgba(0,0,0,.5);color:#fff;padding:8px 10px;border-radius:10px;font-size:12px;line-height:1.5;max-width:42vw;}
  .ok{color:#7CFC00} .warn{color:#FFD700} .err{color:#FF6B6B}
</style>
</head>
<body>
<video id="cam" autoplay playsinline muted></video>
<canvas id="gl"></canvas>

<div class="hud" id="hud">起点: N/A → 终点: N/A<br>距离: — m</div>
<div class="diag" id="diag">加载中…</div>

<div class="panel">
  <div class="row">
    <label>起点</label>
    <select id="start"><option value="">未选择</option></select>
    <label>终点</label>
    <select id="end"><option value="">未选择</option></select>
    <button id="iHere">我在这（点地面）</button>
    <button id="swap">交换起终</button>
  </div>
  <div class="row">
    <label>朝向微调</label>
    <button id="yawMinus">-5°</button>
    <button id="yawPlus">+5°</button>
    <label>高度(m)</label>
    <button id="hDown">-0.2</button>
    <button id="hUp">+0.2</button>
  </div>
</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
(async function(){
  // 固定文件（与 index.html 同目录）
  const FILES = {
    plyPrimary: 'oriented.ply',
    plyFallback: 'sparse.ply',
    rooms: 'rooms_world.geojson'
  };

  const diag = document.getElementById('diag');
  function logLine(html){ diag.innerHTML += '<br>'+html; }
  function setLine(title, status, cls){ logLine(`<span class="${cls}">${title}: ${status}</span>`); }

  // 1) 摄像头（不成功也不阻塞）
  try{
    const t0=performance.now();
    const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ideal:'environment'} }, audio:false });
    document.getElementById('cam').srcObject = stream;
    setLine('Camera', `OK (${(performance.now()-t0|0)}ms)`, 'ok');
  }catch(e){
    setLine('Camera', 'FAILED（但继续加载 3D）', 'warn');
    console.warn(e);
  }

  // 2) Three.js 初始化
  const cnv = document.getElementById('gl');
  const renderer = new THREE.WebGLRenderer({canvas:cnv, antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio||1);
  renderer.setSize(window.innerWidth, window.innerHeight, false);
  const scene = new THREE.Scene(); scene.background = null;
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 5000);
  scene.add(new THREE.AmbientLight(0xffffff,1.0));
  const world = new THREE.Group(); scene.add(world);

  // UI refs
  const hud = document.getElementById('hud');
  const selS = document.getElementById('start');
  const selE = document.getElementById('end');
  const btnHere = document.getElementById('iHere');
  const btnSwap = document.getElementById('swap');
  const yawMinus = document.getElementById('yawMinus');
  const yawPlus = document.getElementById('yawPlus');
  const hDown = document.getElementById('hDown');
  const hUp = document.getElementById('hUp');
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  const groundPlane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

  // 状态
  let rooms = [];
  let startPos = null, endPos = null;
  let userYawDeg = 0, userHeight = 1.6;
  let pcObj = null;

  // 3) 加载 rooms（必须）
  try{
    const t0=performance.now();
    const r = await fetch(FILES.rooms);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const gj = await r.json();
    if (!gj || !gj.features) throw new Error('JSON 无 features');
    rooms = gj.features.map((f,i)=>{
      const prop=f.properties||{};
      const poly=(f.geometry&&f.geometry.type==='Polygon')? f.geometry.coordinates[0] : [];
      return { id: prop.room_id ?? (i+1), name: prop.name ?? '', poly, centroid: centroid(poly) };
    });
    drawRooms(rooms);
    rooms.forEach(r=>{
      const o1=document.createElement('option'); o1.value=String(r.id); o1.textContent=`${r.id}${r.name?(' - '+r.name):''}`; selS.appendChild(o1);
      const o2=document.createElement('option'); o2.value=String(r.id); o2.textContent=`${r.id}${r.name?(' - '+r.name):''}`; selE.appendChild(o2.cloneNode(true));
    });
    if (rooms.length===2){ selS.value=String(rooms[0].id); selE.value=String(rooms[1].id); applyRoomSelection(); }
    setLine('rooms_world.geojson', `OK (${(performance.now()-t0|0)}ms, rooms=${rooms.length})`, 'ok');
  }catch(e){
    setLine('rooms_world.geojson', `FAILED：${e.message||e}`, 'err');
    return; // 没房间就不继续
  }

  // 4) 加载点云（可选）
  try{
    const t0=performance.now();
    let resp = await fetch(FILES.plyPrimary);
    if (!resp.ok) resp = await fetch(FILES.plyFallback);
    if (!resp.ok) throw new Error(`not found: ${FILES.plyPrimary} / ${FILES.plyFallback}`);
    const buf = await resp.arrayBuffer();
    const t1=performance.now();
    const pts = parsePLY(buf);
    const t2=performance.now();
    if (pts.length){
      addPointCloud(pts);
      fitView(pts);
      setLine('PLY', `OK (download ${(t1-t0|0)}ms, parse ${(t2-t1|0)}ms, points ${pts.length})`, 'ok');
    } else {
      setLine('PLY', 'EMPTY / PARSE ZERO', 'warn');
    }
  }catch(e){
    setLine('PLY', `FAILED：${e.message||e}`, 'warn');
  }

  // —— 交互 —— //
  selS.onchange = applyRoomSelection;
  selE.onchange = applyRoomSelection;

  btnHere.onclick = ()=>{ waitingHere=true; setLine('SetHere','Tap on ground plane (y=0)','warn'); };
  let waitingHere=false;
  window.addEventListener('pointerdown', (e)=>{
    if (!waitingHere) return;
    waitingHere=false;
    pointer.x=(e.clientX/window.innerWidth)*2-1;
    pointer.y=-(e.clientY/window.innerHeight)*2+1;
    raycaster.setFromCamera(pointer, camera);
    const hit=new THREE.Vector3();
    if (raycaster.ray.intersectPlane(groundPlane, hit)){
      startPos = new THREE.Vector3(hit.x,0,hit.z);
      selS.value="";
      updatePathAndHUD();
      setLine('SetHere', `OK @ (${hit.x.toFixed(2)}, ${hit.z.toFixed(2)})`, 'ok');
    } else {
      setLine('SetHere', 'No intersection with y=0', 'warn');
    }
  });

  btnSwap.onclick = ()=>{ const tmp=selS.value; selS.value=selE.value; selE.value=tmp; applyRoomSelection(); };
  yawMinus.onclick = ()=> userYawDeg -= 5;
  yawPlus.onclick  = ()=> userYawDeg += 5;
  hDown.onclick    = ()=> userHeight=Math.max(0.8, userHeight-0.2);
  hUp.onclick      = ()=> userHeight=Math.min(3.0, userHeight+0.2);

  // 画房间/路径/箭头
  const roomsGroup = new THREE.Group(); world.add(roomsGroup);
  const pathLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineDashedMaterial({color:0xffffff, dashSize:0.3, gapSize:0.15}));
  pathLine.computeLineDistances(); world.add(pathLine);
  const arrow = makeArrow(); world.add(arrow); arrow.visible=false;

  // 主循环
  function animate(){
    requestAnimationFrame(animate);
    updateArrow();
    renderer.render(scene, camera);
  }
  animate();

  // 自适应
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight, false);
  });

  // ====== helpers ======
  function centroid(poly){
    if(!poly || poly.length<3) return [0,0];
    let x=0,y=0,a=0;
    for(let i=0;i<poly.length;i++){
      const [x0,y0]=poly[i], [x1,y1]=poly[(i+1)%poly.length];
      const c=x0*y1-x1*y0; a+=c; x+=(x0+x1)*c; y+=(y0+y1)*c;
    }
    if (Math.abs(a)<1e-9){ let sx=0,sy=0; for(const p of poly){sx+=p[0];sy+=p[1];} return [sx/poly.length, sy/poly.length]; }
    a*=0.5; x/=(6*a); y/=(6*a); return [x,y];
  }
  function drawRooms(rs){
    roomsGroup.clear();
    const lineMat = new THREE.LineBasicMaterial({color:0x00A2FF});
    const fillMat = new THREE.MeshBasicMaterial({color:0x0066ff, transparent:true, opacity:.12, depthWrite:false});
    rs.forEach(r=>{
      const up=0.02;
      const pts3 = r.poly.map(([x,y])=> new THREE.Vector3(x, up, y));
      const geoLine = new THREE.BufferGeometry().setFromPoints(pts3.concat([pts3[0]]));
      roomsGroup.add(new THREE.Line(geoLine, lineMat));
      const shapexz = new THREE.Shape(); r.poly.forEach(([x,y],k)=> k? shapexz.lineTo(x,y): shapexz.moveTo(x,y));
      shapexz.autoClose = true;
      const geo = new THREE.ShapeGeometry(shapexz);
      const mesh = new THREE.Mesh(geo, fillMat); mesh.rotation.x=-Math.PI/2; mesh.position.y=up;
      roomsGroup.add(mesh);
    });
  }
  function applyRoomSelection(){
    const s = rooms.find(r=> String(r.id)===selS.value);
    const e = rooms.find(r=> String(r.id)===selE.value);
    startPos = s ? new THREE.Vector3(s.centroid[0], 0, s.centroid[1]) : null;
    endPos   = e ? new THREE.Vector3(e.centroid[0], 0, e.centroid[1]) : null;
    updatePathAndHUD();
  }
  function updatePathAndHUD(){
    const geo = new THREE.BufferGeometry();
    const pts = [];
    if (startPos) pts.push(new THREE.Vector3(startPos.x, 0.05, startPos.z));
    if (endPos)   pts.push(new THREE.Vector3(endPos.x,   0.05, endPos.z));
    geo.setFromPoints(pts);
    pathLine.geometry.dispose(); pathLine.geometry = geo;
    pathLine.computeLineDistances();
    let dist='—';
    if (startPos && endPos) dist = startPos.clone().setY(0).distanceTo(endPos.clone().setY(0)).toFixed(2);
    hud.innerHTML = `起点: ${startPos?`${startPos.x.toFixed(2)},${startPos.z.toFixed(2)}`:'N/A'} → 终点: ${endPos?`${endPos.x.toFixed(2)},${endPos.z.toFixed(2)}`:'N/A'}<br>距离: ${dist} m`;
    arrow.visible = !!endPos;
  }
  function updateArrow(){
    if (!endPos || !arrow.visible) return;
    const yaw = THREE.MathUtils.degToRad(userYawDeg);
    const camPos = camera.position.clone();
    const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
    const pos = camPos.clone().addScaledVector(forward, 1.0); pos.y = userHeight;
    arrow.position.copy(pos);
    const target = new THREE.Vector3(endPos.x, pos.y, endPos.z);
    arrow.lookAt(target);
  }
  function makeArrow(){
    const g = new THREE.PlaneGeometry(0.6,0.6);
    const c = document.createElement('canvas'); c.width=256; c.height=256;
    const ctx = c.getContext('2d');
    ctx.strokeStyle='#fff'; ctx.lineWidth=16; ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.beginPath();
    ctx.moveTo(128,32); ctx.lineTo(64,128); ctx.lineTo(104,128); ctx.lineTo(104,224);
    ctx.lineTo(152,224); ctx.lineTo(152,128); ctx.lineTo(192,128); ctx.closePath(); ctx.stroke();
    const tex = new THREE.CanvasTexture(c);
    const m = new THREE.MeshBasicMaterial({map:tex, transparent:true, depthWrite:false});
    return new THREE.Mesh(g,m);
  }
  function addPointCloud(points){
    if (pcObj){ world.remove(pcObj); pcObj.geometry.dispose(); }
    const arr = new Float32Array(points.length*3);
    for(let i=0;i<points.length;i++){ arr[i*3]=points[i][0]; arr[i*3+1]=points[i][1]; arr[i*3+2]=points[i][2]; }
    const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(arr,3));
    const m = new THREE.PointsMaterial({color:0x00ff00, size:0.03, sizeAttenuation:true});
    pcObj = new THREE.Points(g,m); world.add(pcObj);
  }
  function parsePLY(buffer){
    const bytes = new Uint8Array(buffer);
    let hEnd=-1, header=""; for(let i=0;i<bytes.length&&i<1e6;i++){ header+=String.fromCharCode(bytes[i]); if(header.includes("end_header\n")){ hEnd=i+1; break; } }
    if (hEnd<0) return [];
    const lines = header.split(/\r?\n/);
    let n=0,isBin=false,little=true; const props=[];
    for(const Lraw of lines){
      const L=Lraw.trim().toLowerCase();
      if(L.startsWith("format binary_little_endian")){ isBin=true; little=true; }
      if(L.startsWith("format ascii")) isBin=false;
      if(L.startsWith("element vertex")) n=parseInt(L.split(/\s+/)[2],10);
      if(L.startsWith("property")){ const p=L.split(/\s+/); if(p.length>=3) props.push({type:p[1],name:p[2]}); }
    }
    if(!n) return [];
    const pts=new Array(n);
    if(!isBin){
      const tail = new TextDecoder().decode(bytes.slice(hEnd));
      const rows = tail.split(/\r?\n/); let k=0;
      for(const r of rows){ const s=r.trim(); if(!s) continue; const t=s.split(/\s+/); if(t.length>=3){ pts[k++]=[+t[0],+t[1],+t[2]]; if(k>=n) break; } }
      return pts.slice(0,n);
    } else {
      const view=new DataView(buffer,hEnd); let off=0;
      function read(type,off){ switch(type){
        case'float':case'float32':return[view.getFloat32(off,little),4];
        case'double':return[view.getFloat64(off,little),8];
        case'uchar':case'uint8':return[view.getUint8(off),1];
        case'char':case'int8':return[view.getInt8(off),1];
        case'ushort':case'uint16':return[view.getUint16(off,little),2];
        case'short':case'int16':return[view.getInt16(off,little),2];
        case'uint':case'uint32':return[view.getUint32(off,little),4];
        case'int':case'int32':return[view.getInt32(off,little),4];
        default:return[0,0];}}
      for(let i=0;i<n;i++){
        let x=0,y=0,z=0;
        for(const p of props){ const [v,step]=read(p.type,off); off+=step; if(p.name==='x')x=v; else if(p.name==='y')y=v; else if(p.name==='z')z=v; }
        pts[i]=[x,y,z];
      }
      return pts;
    }
  }
  function fitView(points){
    let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;
    for(const p of points){ const [x,y,z]=p; if(x<minX)minX=x; if(y<minY)minY=y; if(z<minZ)minZ=z; if(x>maxX)maxX=x; if(y>maxY)maxY=y; if(z>maxZ)maxZ=z; }
    const cx=(minX+maxX)/2, cy=(minY+maxY)/2, cz=(minZ+maxZ)/2; const span=Math.max(maxX-minX,maxY-minY,maxZ-minZ);
    camera.position.set(cx, cy+span*0.2, cz+span*1.2); camera.lookAt(cx,cy,cz);
  }
})();
</script>
</body>
</html>
