<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>Marker AR 导航（iOS+Android 双平台，无 WebXR）</title>
<style>
  html,body{margin:0;background:#000;overflow:hidden;touch-action:none;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  #cam{position:fixed;left:0;top:0;width:100vw;height:100vh;object-fit:cover;background:#000;z-index:0;}
  #gl{position:fixed;left:0;top:0;width:100vw;height:100vh;z-index:1;pointer-events:none;}
  .panel{position:fixed;left:12px;right:12px;bottom:12px;z-index:3;background:rgba(0,0,0,.45);color:#fff;border-radius:12px;padding:10px 12px;backdrop-filter:blur(6px);}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:6px}
  select,button{font-size:12px;background:#111;color:#fff;border:1px solid #333;border-radius:8px;padding:6px 8px}
  .hud{position:fixed;left:12px;top:12px;z-index:3;background:rgba(0,0,0,.35);color:#fff;padding:8px 10px;border-radius:10px;font-size:12px;line-height:1.4}
  .tip{position:fixed;left:50%;transform:translateX(-50%);top:8px;z-index:3;background:rgba(0,0,0,.35);color:#fff;padding:6px 10px;border-radius:10px;font-size:12px}
</style>
</head>
<body>
<video id="cam" autoplay playsinline muted></video>
<canvas id="gl"></canvas>
<div class="tip" id="tip">加载中…</div>
<div class="hud" id="hud">markers: 0 | pose: N/A</div>
<div class="panel">
  <div class="row">
    <label>目标房间</label>
    <select id="room"><option value="">未选择</option></select>
    <button id="clear">清除</button>
    <button id="recenter">重置对齐</button>
  </div>
</div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<!-- OpenCV.js（ArUco 支持） -->
<script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

<script>
(async function(){
  // -------- 固定文件名（与 index.html 同目录） --------
  const FILES = {
    ply: 'oriented.ply',            // 若没有就换成 sparse.ply
    rooms: 'rooms_world.geojson',   // 世界坐标(米)
    markers: 'markers_world.json'   // 标记世界位姿配置
  };

  // --------- UI refs ----------
  const tip = document.getElementById('tip');
  const hud = document.getElementById('hud');
  const roomSel = document.getElementById('room');
  const btnClear = document.getElementById('clear');
  const btnRecenter = document.getElementById('recenter');

  function toast(s){ tip.textContent=s; tip.style.opacity='1'; clearTimeout(toast._t); toast._t=setTimeout(()=>tip.style.opacity='.6',1500); }

  // --------- Camera ----------
  const camVideo = document.getElementById('cam');
  const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}}, audio:false})
    .catch(e=>{toast('相机权限失败'); throw e;});
  camVideo.srcObject = stream;
  await camVideo.play();

  // --------- Three.js ----------
  const cnv = document.getElementById('gl');
  const renderer = new THREE.WebGLRenderer({canvas:cnv, antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio||1);
  renderer.setSize(window.innerWidth, window.innerHeight, false);
  const scene = new THREE.Scene(); scene.background = null;
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.01, 5000);
  scene.add(new THREE.AmbientLight(0xffffff,1.0));

  // “世界内容”放在 worldGroup，坐标单位=米
  const worldGroup = new THREE.Group(); worldGroup.matrixAutoUpdate = false;
  scene.add(worldGroup);

  // 箭头（看向目标）
  const arrow = makeBillboardArrow(); arrow.visible=false; worldGroup.add(arrow);

  // --------- 数据加载 ----------
  async function fetchMaybe(url){ try{ const r=await fetch(url); if(!r.ok) return null; return r; }catch{ return null; } }
  // rooms
  const roomsGJ = await (await fetchMaybe(FILES.rooms))?.json();
  let rooms = []; // {id,name,centroid:[x,y],poly:[[x,y]...]}
  if (roomsGJ && roomsGJ.features) {
    rooms = roomsGJ.features.map((f,i)=>{
      const prop=f.properties||{};
      const poly=(f.geometry&&f.geometry.type==='Polygon')? f.geometry.coordinates[0] : [];
      return { id: prop.room_id ?? (i+1), name: prop.name ?? '', poly, centroid: centroid(poly) };
    });
    addRooms(worldGroup, rooms);
    rooms.forEach(r=> {
      const opt=document.createElement('option');
      opt.value=String(r.id); opt.textContent = `${r.id}${r.name?(' - '+r.name):''}`;
      roomSel.appendChild(opt);
    });
  } else {
    toast('rooms_world.geojson 缺失或解析失败');
  }
  // target
  let targetPos = null;
  roomSel.onchange = ()=>{
    const val = roomSel.value; if(!val){ targetPos=null; arrow.visible=false; return; }
    const r = rooms.find(x=> String(x.id)===val);
    if (r){ targetPos = new THREE.Vector3(r.centroid[0], 0, r.centroid[1]); arrow.visible=true; }
  };
  btnClear.onclick = ()=>{ roomSel.value=''; targetPos=null; arrow.visible=false; };

  // point cloud
  const plyResp = await fetchMaybe(FILES.ply) || await fetchMaybe('sparse.ply');
  if (plyResp) {
    const buf = await plyResp.arrayBuffer();
    const pts = parsePLY(buf);
    if (pts.length) addPointCloud(worldGroup, pts);
  } else {
    toast('未找到 PLY');
  }

  // markers config
  // markers_world.json 样例：
  // {
  //   "aruco_dict": "DICT_4X4_50",
  //   "marker_size_m": 0.14,
  //   "markers": [
  //     {"id": 7, "pos": [12.34, 0.00, 5.67], "yaw_deg": 90},
  //     {"id": 12, "pos": [3.2, 0.00, 18.9], "yaw_deg": 0}
  //   ]
  // }
  const markerCfg = await (await fetchMaybe(FILES.markers))?.json();
  if (!markerCfg) toast('未找到 markers_world.json（可先上墙1~2个标记）');

  // --------- OpenCV.js 初始化（ArUco）----------
  await cvReady();
  const dict = getArucoDict((markerCfg && markerCfg.aruco_dict) || 'DICT_4X4_50');
  const params = new cv.DetectorParameters();
  const camMat = cameraMatrixFromFOV(camVideo.videoWidth, camVideo.videoHeight, 60); // 用 FOV 估相机内参
  const distCoeffs = cv.Mat.zeros(1,5,cv.CV_64F); // 先当无畸变

  // 画面缓冲
  const capCanvas = document.createElement('canvas');
  capCanvas.width = camVideo.videoWidth; capCanvas.height = camVideo.videoHeight;
  const capCtx = capCanvas.getContext('2d');

  // 位姿状态（XR风格：相机在世界系中的位姿）
  let havePose = false;
  let camWorld_R = new THREE.Matrix4();  // 3x3旋转（扩展为4x4）
  let camWorld_t = new THREE.Vector3();  // 平移
  // 将“世界内容”放入相机坐标 → 可反过来（把相机放世界），我们用等效变换：计算 worldGroup.matrix = cam->world 的逆
  // 这里我们直接算 world->camera，再取逆

  // 重置
  btnRecenter.onclick = ()=>{ havePose=false; };

  // --------- 渲染+跟踪主循环 ----------
  function loop(){
    requestAnimationFrame(loop);

    // 抓一帧
    capCtx.drawImage(camVideo, 0, 0, capCanvas.width, capCanvas.height);
    const src = cv.imread(capCanvas);

    // 检测 ArUco
    const corners = new cv.MatVector();
    const ids = new cv.Mat();
    cv.detectMarkers(src, dict, corners, ids, params);

    let nMarkers = 0;
    if (!ids.empty() && markerCfg && markerCfg.markers && markerCfg.markers.length) {
      const size = (markerCfg.marker_size_m || 0.14); // 每个标记边长（米）
      // 收集匹配到的世界锚点与相机观测的 rvec/tvec
      const obs = []; // {id, rvec, tvec, worldPoseOfMarker}
      for (let i=0; i<ids.rows; i++){
        const id = ids.intAt(i,0);
        const idx = markerCfg.markers.findIndex(m => m.id === id);
        if (idx<0) continue;
        const c = corners.get(i);
        const rvec = new cv.Mat(); const tvec = new cv.Mat();
        cv.estimatePoseSingleMarkers(new cv.MatVector([c]), size, camMat, distCoeffs, new cv.MatVector([rvec]), new cv.MatVector([tvec]));
        obs.push({ id, rvec, tvec, world: markerCfg.markers[idx] });
        nMarkers++;
      }

      if (obs.length>0) {
        // 用单个或多个标记融合相机位姿（这里先用“最佳一个”：离相机最近的那个）
        obs.sort((a,b)=> {
          const za = a.tvec.doubleAt(2,0), zb = b.tvec.doubleAt(2,0);
          return za - zb;
        });
        const best = obs[0];
        const RT_cam_from_marker = rtFromRvecTvec(best.rvec, best.tvec); // 相机 <- 标记
        const RT_world_from_marker = worldFromMarker(best.world);        // 世界 <- 标记
        // 相机 <- 世界 = (相机 <- 标记) ∘ (标记 <- 世界) = RT_cm ∘ inverse(RT_wm)
        const RT_marker_from_world = new THREE.Matrix4().copy(RT_world_from_marker).invert();
        const RT_cam_from_world = new THREE.Matrix4().multiplyMatrices(RT_cam_from_marker, RT_marker_from_world);
        // worldGroup 要放到“世界 -> 相机”的逆，也就是“相机 -> 世界”
        const RT_world_from_cam = new THREE.Matrix4().copy(RT_cam_from_world).invert();
        worldGroup.matrix.copy(RT_world_from_cam);
        havePose = true;

        // 释放
        obs.forEach(o=>{ o.rvec.delete(); o.tvec.delete(); });
      }
    }

    // 更新箭头（放在相机前方 1m，朝向目标）
    const arrowObj = arrow;
    if (targetPos && havePose) {
      arrowObj.visible = true;
      // 相机在世界坐标：取 worldGroup.matrix 的逆 * 相机原点(0,0,0)
      const camToWorld = new THREE.Matrix4().copy(worldGroup.matrix);
      const worldToCam = new THREE.Matrix4().copy(camToWorld).invert();
      const camW = new THREE.Vector3(0,0,0).applyMatrix4(camToWorld);
      // 前方 1m（世界）
      const forwardW = new THREE.Vector3(0,0,-1).applyMatrix4(new THREE.Matrix4().extractRotation(camToWorld)); // 摄像机 -Z 方向
      const posW = camW.clone().addScaledVector(forwardW, 1.0);
      // 放置
      arrowObj.position.copy(posW);
      // 朝向目标
      const tgt = targetPos.clone();
      arrowObj.lookAt(new THREE.Vector3(tgt.x, arrowObj.position.y, tgt.z));
    } else {
      arrowObj.visible = false;
    }

    // 渲染
    renderer.render(scene, camera);
    hud.textContent = `markers: ${nMarkers} | pose: ${havePose?'OK':'N/A'}`;

    // 清理
    src.delete(); corners.delete(); ids.delete();
  }
  loop();

  // --------- 工具函数 ---------
  function centroid(poly){
    if(!poly || poly.length<3) return [0,0];
    let x=0,y=0,a=0;
    for(let i=0;i<poly.length;i++){
      const [x0,y0]=poly[i], [x1,y1]=poly[(i+1)%poly.length];
      const c=x0*y1-x1*y0; a+=c; x+=(x0+x1)*c; y+=(y0+y1)*c;
    }
    if (Math.abs(a)<1e-9){ let sx=0,sy=0; for(const p of poly){sx+=p[0];sy+=p[1];} return [sx/poly.length, sy/poly.length]; }
    a*=0.5; x/=(6*a); y/=(6*a); return [x,y];
  }

  function addRooms(parent, rooms){
    const group = new THREE.Group();
    const lineMat = new THREE.LineBasicMaterial({color:0x00A2FF});
    const fillMat = new THREE.MeshBasicMaterial({color:0x0066ff,transparent:true,opacity:.12,depthWrite:false});
    rooms.forEach(r=>{
      const up=0.02;
      const pts3 = r.poly.map(([x,y])=> new THREE.Vector3(x, up, y));
      const geoLine = new THREE.BufferGeometry().setFromPoints(pts3.concat([pts3[0]]));
      group.add(new THREE.Line(geoLine, lineMat));
      const shapexz = new THREE.Shape(); r.poly.forEach(([x,y],k)=> k? shapexz.lineTo(x,y): shapexz.moveTo(x,y));
      shapexz.autoClose=true;
      const geo = new THREE.ShapeGeometry(shapexz);
      const mesh = new THREE.Mesh(geo, fillMat); mesh.rotation.x=-Math.PI/2; mesh.position.y=up;
      group.add(mesh);
    });
    parent.add(group);
  }

  function makeBillboardArrow(){
    const g = new THREE.PlaneGeometry(0.6,0.6);
    const c = document.createElement('canvas'); c.width=256; c.height=256;
    const ctx = c.getContext('2d');
    ctx.strokeStyle='#fff'; ctx.lineWidth=16; ctx.lineCap='round'; ctx.lineJoin='round';
    ctx.beginPath();
    ctx.moveTo(128,32); ctx.lineTo(64,128); ctx.lineTo(104,128); ctx.lineTo(104,224);
    ctx.lineTo(152,224); ctx.lineTo(152,128); ctx.lineTo(192,128); ctx.closePath(); ctx.stroke();
    const tex = new THREE.CanvasTexture(c);
    const m = new THREE.MeshBasicMaterial({map:tex, transparent:true, depthWrite:false});
    const mesh = new THREE.Mesh(g,m);
    return mesh;
  }

  function addPointCloud(parent, points){
    const arr = new Float32Array(points.length*3);
    for(let i=0;i<points.length;i++){ arr[i*3]=points[i][0]; arr[i*3+1]=points[i][1]; arr[i*3+2]=points[i][2]; }
    const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.BufferAttribute(arr,3));
    const m = new THREE.PointsMaterial({color:0x00ff00, size:0.03, sizeAttenuation:true});
    const cloud = new THREE.Points(g,m); parent.add(cloud);
  }

  function parsePLY(buffer){
    const bytes = new Uint8Array(buffer);
    let hEnd=-1, head=""; for(let i=0;i<bytes.length&&i<1e6;i++){ head+=String.fromCharCode(bytes[i]); if(head.includes("end_header\n")){ hEnd=i+1; break; } }
    if(hEnd<0) return [];
    const lines = head.split(/\r?\n/);
    let n=0,isBin=false,little=true; const props=[];
    for(const Lraw of lines){
      const L=Lraw.trim().toLowerCase();
      if(L.startsWith("format binary_little_endian")){ isBin=true; little=true; }
      if(L.startsWith("format ascii")) isBin=false;
      if(L.startsWith("element vertex")) n=parseInt(L.split(/\s+/)[2],10);
      if(L.startsWith("property")){ const p=L.split(/\s+/); if(p.length>=3) props.push({type:p[1],name:p[2]}); }
    }
    if(!n) return [];
    const pts=new Array(n);
    if(!isBin){
      const tail = new TextDecoder().decode(bytes.slice(hEnd));
      const rows = tail.split(/\r?\n/); let k=0;
      for(const r of rows){ const s=r.trim(); if(!s) continue; const t=s.split(/\s+/); if(t.length>=3){ pts[k++]=[+t[0],+t[1],+t[2]]; if(k>=n) break; } }
      return pts.slice(0,n);
    } else {
      const view=new DataView(buffer,hEnd); let off=0;
      function read(type,off){ switch(type){
        case'float':case'float32':return[view.getFloat32(off,little),4];
        case'double':return[view.getFloat64(off,little),8];
        case'uchar':case'uint8':return[view.getUint8(off),1];
        case'char':case'int8':return[view.getInt8(off),1];
        case'ushort':case'uint16':return[view.getUint16(off,little),2];
        case'short':case'int16':return[view.getInt16(off,little),2];
        case'uint':case'uint32':return[view.getUint32(off,little),4];
        case'int':case'int32':return[view.getInt32(off,little),4];
        default:return[0,0];}}
      for(let i=0;i<n;i++){
        let x=0,y=0,z=0;
        for(const p of props){ const [v,step]=read(p.type,off); off+=step; if(p.name==='x')x=v; else if(p.name==='y')y=v; else if(p.name==='z')z=v; }
        pts[i]=[x,y,z];
      }
      return pts;
    }
  }

  function cvReady(){
    return new Promise(res=>{
      if (window.cv && cv.getBuildInformation) return res();
      document.addEventListener('opencvready', res);
    });
  }

  function getArucoDict(name){
    // 仅列常用的：4x4_50 / 5x5_100 / 6x6_250 等
    const map = {
      'DICT_4X4_50': cv.DICT_4X4_50,
      'DICT_5X5_100': cv.DICT_5X5_100,
      'DICT_6X6_250': cv.DICT_6X6_250,
      'DICT_7X7_1000': cv.DICT_7X7_1000
    };
    const key = map[name] || cv.DICT_4X_4_50 || cv.DICT_4X4_50;
    return new cv.Dictionary(key);
  }

  function cameraMatrixFromFOV(w,h,fovDeg){
    const f = 0.5*h / Math.tan((fovDeg*Math.PI/180)/2);
    const K = cv.Mat.eye(3,3,cv.CV_64F);
    K.doublePtr(0,0)[0] = f; // fx
    K.doublePtr(1,1)[0] = f; // fy
    K.doublePtr(0,2)[0] = w/2; // cx
    K.doublePtr(1,2)[0] = h/2; // cy
    return K;
  }

  function rtFromRvecTvec(rvec, tvec){
    // OpenCV rvec/tvec -> THREE Matrix4
    const R = new cv.Mat();
    cv.Rodrigues(rvec, R);
    const m = new THREE.Matrix4();
    const e = m.elements;
    // OpenCV 是列主序 3x3，这里手填
    e[0]=R.doubleAt(0,0); e[4]=R.doubleAt(0,1); e[8] =R.doubleAt(0,2); e[12]=tvec.doubleAt(0,0);
    e[1]=R.doubleAt(1,0); e[5]=R.doubleAt(1,1); e[9] =R.doubleAt(1,2); e[13]=tvec.doubleAt(1,0);
    e[2]=R.doubleAt(2,0); e[6]=R.doubleAt(2,1); e[10]=R.doubleAt(2,2); e[14]=tvec.doubleAt(2,0);
    e[3]=0; e[7]=0; e[11]=0; e[15]=1;
    R.delete();
    return m;
  }

  function worldFromMarker(m){
    // 已知“标记在世界坐标”的位姿：pos=[x,y,z], yaw_deg（绕+Y）
    const T = new THREE.Matrix4().makeTranslation(m.pos[0], m.pos[1], m.pos[2]);
    const R = new THREE.Matrix4().makeRotationY(m.yaw_deg ? m.yaw_deg*Math.PI/180 : 0);
    return new THREE.Matrix4().multiplyMatrices(T, R);
  }

  // 自适应画布
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight, false);
  });
})();
</script>
</body>
</html>
