<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>WebXR + Three.js 一页式 WebAR 示例</title>
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; }
    #info {
      position: fixed; left: 0; right: 0; bottom: 0;
      padding: 10px 12px; color:#fff; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, rgba(0,0,0,.0), rgba(0,0,0,.55));
      pointer-events: none;
      text-align: center;
    }
    .ar-supported #hint { opacity:.9 }
    #hint { opacity:.75 }
    .hidden { display:none }
    canvas { touch-action: none; }
  </style>
</head>
<body>
  <div id="info">
    <div id="hint">对着地面慢慢移动手机让圆环锁定平面；点击屏幕放置一个小方块。</div>
    <div id="unsupported" class="hidden">此设备/浏览器不支持 WebXR AR。请使用 Android 的 Chrome 并通过 HTTPS/localhost 打开。</div>
  </div>

  <script type="module">
    // 采用 ESM CDN（也可改成本地依赖）
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.160.0/examples/jsm/webxr/ARButton.js';

    // 基础场景
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 30);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // 柔和一点的光
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(1, 2, 1);
    scene.add(dir);

    // 命中指示器（reticle）：一个贴地小圆环
    const reticleGeo = new THREE.RingGeometry(0.07, 0.09, 32).rotateX(-Math.PI / 2);
    const reticleMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.9 });
    const reticle = new THREE.Mesh(reticleGeo, reticleMat);
    reticle.matrixAutoUpdate = false;  // 用设备返回的姿态矩阵直接更新
    reticle.visible = false;
    scene.add(reticle);

    // 点击放置：从 XR 控制器（触摸）拿事件
    const controller = renderer.xr.getController(0);
    controller.addEventListener('select', () => {
      if (!reticle.visible) return;
      // 放一个 10cm 的小方块
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(0.1, 0.1, 0.1),
        new THREE.MeshStandardMaterial({ color: 0x42a5f5, metalness: 0.1, roughness: 0.8 })
      );
      // 把 reticle 的世界矩阵应用到 box
      box.position.setFromMatrixPosition(reticle.matrix);
      const quat = new THREE.Quaternion().setFromRotationMatrix(reticle.matrix);
      box.quaternion.copy(quat);
      scene.add(box);
    });
    scene.add(controller);

    // WebXR Hit Test 所需变量
    let hitTestSource = null;
    let viewerSpace = null;
    let localSpace = null;

    // 创建进入 AR 的按钮，并声明需要 hit-test
    // 注意：必须在 HTTPS 或 localhost 下，且设备/浏览器支持 WebXR-AR
    const arButton = ARButton.createButton(renderer, {
      requiredFeatures: ['hit-test'],               // 命中测试
      optionalFeatures: ['dom-overlay'],            // 可选：把按钮/提示覆盖在画面上
      domOverlay: { root: document.body }
    });
    document.body.appendChild(arButton);

    // 支持性检查（用于显示提示）
    if (navigator.xr && navigator.xr.isSessionSupported) {
      navigator.xr.isSessionSupported('immersive-ar').then(supported => {
        document.body.classList.toggle('ar-supported', supported);
        if (!supported) document.getElementById('unsupported').classList.remove('hidden');
      }).catch(() => {
        document.getElementById('unsupported').classList.remove('hidden');
      });
    } else {
      document.getElementById('unsupported').classList.remove('hidden');
    }

    // 当开始 AR 会话时，向 XR 系统申请 hit test 源
    renderer.xr.addEventListener('sessionstart', async () => {
      const session = renderer.xr.getSession();
      viewerSpace = await session.requestReferenceSpace('viewer');
      localSpace = await session.requestReferenceSpace('local');
      hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

      // 可选：当会话结束时清理
      session.addEventListener('end', () => {
        hitTestSource = null;
        viewerSpace = null;
        localSpace = null;
        reticle.visible = false;
      });
    });

    // 每帧执行：做 hit test，更新 reticle
    renderer.setAnimationLoop((timestamp, frame) => {
      if (frame && hitTestSource && localSpace) {
        const hitTestResults = frame.getHitTestResults(hitTestSource);
        if (hitTestResults.length > 0) {
          const referenceSpace = localSpace;
          const hit = hitTestResults[0];
          const pose = hit.getPose(referenceSpace);
          if (pose) {
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          }
        } else {
          reticle.visible = false;
        }
      }
      renderer.render(scene, camera);
    });

    // 自适应窗口
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
